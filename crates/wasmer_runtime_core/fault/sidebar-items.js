initSidebarItems({"constant":[["BOUNDARY_REGISTER_PRESERVATION",""],["CURRENT_CODE_VERSIONS",""],["CURRENT_CTX",""],["INTERRUPT_SIGNAL_MEM_SIZE",""],["SETJMP_BUFFER_LEN",""],["TRAP_STACK_SIZE",""],["UNWIND",""],["WAS_SIGINT_TRIGGERED",""]],"fn":[["allocate_and_run","Allocates and runs with the given stack size and closure."],["begin_unsafe_unwind","Begins an unsafe unwind."],["catch_unsafe_unwind","Catches an unsafe unwind with the given functions and breakpoints."],["clear_wasm_interrupt","Clears the wasm interrupt."],["ensure_sighandler","Ensure the signal handler is installed."],["get_boundary_register_preservation","Gets a mutable pointer to the `BoundaryRegisterPreservation`."],["get_fault_info","Get fault info from siginfo and ucontext."],["get_wasm_interrupt_signal_mem","Gets the wasm interrupt signal mem."],["install_sighandler",""],["pop_code_version","Pops a `CodeVersion` from the current code versions."],["push_code_version","Pushes a new `CodeVersion` to the current code versions."],["run_on_alternative_stack",""],["set_wasm_interrupt","Sets a wasm interrupt."],["set_wasm_interrupt_on_ctx","Sets the wasm interrupt on the given `Ctx`."],["sigint_handler",""],["signal_trap_handler",""],["was_sigint_triggered_fault","Returns a boolean indicating if SIGINT triggered the fault."],["with_breakpoint_map",""],["with_ctx","Runs a callback function with the given `Ctx`."]],"mod":[["raw","The raw module contains required externed function interfaces for the fault module."]],"static":[["INSTALL_SIGHANDLER",""],["INTERRUPT_SIGNAL_DELIVERED",""],["INTERRUPT_SIGNAL_MEM",""]],"struct":[["BoundaryRegisterPreservation","A store for boundary register preservation."],["FaultInfo","Info about the fault"],["INTERRUPT_SIGNAL_MEM",""],["InterruptSignalMem",""],["UnwindInfo",""]],"type":[["SetJmpBuffer",""]]});